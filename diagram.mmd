
---
title: Testing generation of schemes
---
classDiagram

	class Ownable {
		ğŸ”’ address _owner
		â—ğŸ‘€ owner() address 
		âš™ï¸ğŸ‘€ _checkOwner() 
		â— renounceOwnership() 
		â— transferOwnership(address newOwner) 
		âš™ï¸ _transferOwnership(address newOwner) 
	}

	class FeeManager {
		ğŸ”’ uint112 _feeIn
		ğŸ”’ uint112 _feeOut
		â— uint32 feePrecision
		ğŸ”’ address _feeTo
		â— setFees(uint112 feeIn_, uint112 feeOut_) 
		â— setFeeTo(address feeTo_) 
		âš™ï¸ğŸ§® _calculateFee(uint amount, uint112 fee) uint 
		â—ğŸ‘€ feeIn() uint112 
		â—ğŸ‘€ feeOut() uint112 
		â—ğŸ‘€ feeTo() address 
	}

	class AddressProviderKeeper {
		ğŸ”’ IMaatAddressProvider _addressProvider
		â— bytes4 AddressProviderInterfaceId
		ğŸ”’ğŸ‘€ _validateAddressProviderInterface(address addressProvider_) 
		â—ğŸ‘€ addressProvider() IMaatAddressProvider 
	}

	class Roles {
		â— address commander
		â— address watcher
		â— setCommander(address _commander) 
		â— setWatcher(address _watcher) 
	}

	class WithdrawRequestLogic {
		â— uint cancelWithdrawTimer
		â— uint32 chainEid
		âš™ï¸ mapping(uint32 => bool) _supportedDstEidToWithdraw
		ğŸ”’ mapping(bytes32 => WithdrawRequestInfo) _withdrawRequests
		â— setWithdrawCancelTimer(uint timer) 
		âš™ï¸ _createWithdrawRequest(bytes32 intentionId, address _owner, address receiver, address asset, uint32 dstEid, uint shares) 
		âš™ï¸ _cancelWithdrawRequest(bytes32 intentionId) owner shares 
		âš™ï¸ _cleanRequestInfo(address owner, bytes32 intentionId) 
		â— addChainToWithdraw(uint32 _dstEid) 
		â— removeChainToWithdraw(uint32 _dstEid) 
		â—ğŸ‘€ getWithdrawRequest(bytes32 intentionId) WithdrawRequestInfo 
		â—ğŸ‘€ getSupportedDstEidToWithdraw(uint32 _dstEid) bool 
		âš™ï¸ğŸ‘€ _validateWithdrawRequestExistence(bytes32 intentionId) 
	}

	class TokenKeeper {
		â— ERC20 token
		ğŸ”’ uint _idle
		âš™ï¸ _increaseIdle(uint value) 
		âš™ï¸ _decreaseIdle(uint value) 
		â—ğŸ‘€ idle() uint 
	}

	class StrategyManager {
		ğŸ”’ mapping(bytes32 => Strategy) _supportedStrategies
		ğŸ”’ mapping(address => bytes32) _strategyAddressToId
		â— addStrategy(address strategy) 
		â— removeStrategy(bytes32 strategyId) 
		â— enableStrategy(bytes32 strategyId) 
		â— disableStrategy(bytes32 strategyId) 
		âš™ï¸ _deleteStrategy(bytes32 strategyId, address strategy) 
		âš™ï¸ _toggleStrategy(bytes32 strategyId, bool isActive) 
		â—ğŸ‘€ getStrategyByAddress(address strategy) bytes32 bool 
		â—ğŸ‘€ getStrategyById(bytes32 strategyId) address bool 
		âš™ï¸ğŸ‘€ _validateStrategyExistence(bytes32 strategyId) 
		âš™ï¸ğŸ‘€ _validateStrategyExistence(address strategy) 
	}

	class BridgeLogic {
		â—ğŸ‘€ stargateAdapter() IStargateAdapter 
		â— finishBridge(uint256 amountBridged, bytes32 intentionId) 
		âš™ï¸ _finishBridge(uint amountBridged, address sender) 
		âš™ï¸ _bridge(uint256 _amount, uint256 dstEid, bytes32 intentionId) 
		âš™ï¸ _bridgeToUser(uint amount, address _receiver, uint32 dstEid) 
	}

	class Executor {
		â— execute(ActionType[] actionType, ActionInput[] inputs) bool 
		âš™ï¸ _execute(ActionType _type, ActionInput input) 
		âš™ï¸ _depositInStrategy(bytes32 _strategyId, uint amount, bytes32 intentionId) shares 
		âš™ï¸ _withdrawFromStrategy(bytes32 _strategyId, uint amount, bytes32 intentionId) shares 
		âš™ï¸ _fulfillWithdrawRequest(bytes32 intentionId) 
	}

	class TokenVault {
		â— uint minAmount
		â— deposit(uint _assets, address _receiver) shares 
		â— mint(uint shares, address receiver) assets 
		â— withdraw(uint _assets, address _receiver, address _owner) shares 
		â— redeem(uint256 _shares, address _receiver, address _owner) assets 
		âš™ï¸ _deposit(uint assets, uint shares, address _owner, address receiver) adjustedAssets adjustedShares 
		âš™ï¸ _redeem(uint _shares, address _receiver, address _owner) assets 
		âš™ï¸ _withdraw(uint _assets, address _receiver, address _owner) adjustedShares 
		âš™ï¸ _sendFunds(address _receiver, uint _assets, uint _shares, uint fee) 
		âš™ï¸ _sendFee(uint fee) 
		â— setMinAmount(uint amount) 
		âš™ï¸ğŸ‘€ _getVaultName(address _asset) string 
		âš™ï¸ğŸ‘€ _getVaultSymbol(address _asset) string 
		â—ğŸ‘€ oracle() IMaatOracleGlobalPPS 
		â—ğŸ‘€ asset() address 
		â—ğŸ‘€ totalAssets() uint 
		â—ğŸ‘€ convertToShares(uint assets) uint 
		âš™ï¸ğŸ‘€ _convertToSharesByPrevPPS(uint assets) uint 
		â—ğŸ‘€ convertToAssets(uint shares) uint 
		âš™ï¸ğŸ‘€ _convertToAssetsByPrevPPS(uint shares) uint 
		â—ğŸ‘€ maxDeposit(address receiver) uint256 
		â—ğŸ‘€ maxMint(address receiver) uint256 
		â—ğŸ‘€ maxRedeem(address receiver) uint 
		â—ğŸ‘€ maxWithdraw(address receiver) uint 
		â—ğŸ‘€ previewDeposit(uint assets) uint 
		â—ğŸ‘€ previewMint(uint shares) uint 
		â—ğŸ‘€ previewWithdraw(uint assets) uint 
		â—ğŸ‘€ previewRedeem(uint shares) uint 
		â—ğŸ‘€ decimals() uint8 
		âš™ï¸ğŸ§® _validateUser(address _owner, address sender) 
		âš™ï¸ğŸ‘€ _validateMinAmount(uint amount) 
	}

	class MaatVaultV1 {
		âš™ï¸ bytes4 vaultInterfaceId
		â— requestWithdraw(uint shares, uint32 dstEid, address _owner, address receiver) intentionId 
		â— requestRebalance() intentionId 
		â— cancelWithdrawal(bytes32 intentionId) owner shares 
		âš™ï¸ _fulfillWithdrawRequest(bytes32 intentionId) 
		â—ğŸ‘€ getIntentionId(address sender, RequestType _type) bytes32 
	}



	Ownable <|-- FeeManager

	Ownable <|-- Roles

	Ownable <|-- WithdrawRequestLogic

	Ownable <|-- StrategyManager

	AddressProviderKeeper <|-- StrategyManager

	TokenKeeper <|-- StrategyManager

	AddressProviderKeeper <|-- BridgeLogic

	TokenKeeper <|-- BridgeLogic

	Roles <|-- Executor

	BridgeLogic <|-- Executor

	StrategyManager <|-- Executor

	WithdrawRequestLogic <|-- Executor

	Ownable <|-- TokenVault

	AddressProviderKeeper <|-- TokenVault

	FeeManager <|-- TokenVault

	TokenKeeper <|-- TokenVault

	TokenVault <|-- MaatVaultV1

	Executor <|-- MaatVaultV1